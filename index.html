<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Stacker Game - A Modern Tetris-like Puzzle</title>
    <meta name="description" content="Enjoy Block Stacker, a modern take on the classic Tetris puzzle game. Stack blocks, clear lines, and challenge your skills in this addictive browser game!">
    <meta name="keywords" content="Block Stacker, Tetris, puzzle game, browser game, HTML5 game">
    <meta name="author" content="Shane Larson">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://grizzlypeaksoftware.github.io/block-stacker/">
    <meta property="og:title" content="Block Stacker - A Modern Tetris-like Puzzle Game">
    <meta property="og:description" content="Stack blocks, clear lines, and challenge your skills in this addictive browser-based puzzle game. Play Block Stacker now!">
    <meta property="og:image" content="https://grizzlypeaksoftware.github.io/block-stacker/gameimage.jpg">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://grizzlypeaksoftware.github.io/block-stacker/">
    <meta property="twitter:title" content="Block Stacker - A Modern Tetris-like Puzzle Game">
    <meta property="twitter:description" content="Stack blocks, clear lines, and challenge your skills in this addictive browser-based puzzle game. Play Block Stacker now!">
    <meta property="twitter:image" content="https://grizzlypeaksoftware.github.io/block-stacker/gameimage.jpg">

    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #222;
            color: #fff;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 2em;
            margin-bottom: 20px;
            text-align: center;
            color: #ff6b6b;
            text-shadow: 2px 2px #4ecdc4;
        }
        canvas {
            border: 1px solid #4ecdc4;
            display: block;
        }
        #controls {
            display: none;
            margin-top: 20px;
        }
        #controls button {
            font-size: 24px;
            margin: 5px;
            padding: 10px 20px;
            background-color: #4ecdc4;
            border: none;
            color: #222;
            cursor: pointer;
        }
        #instructions {
            margin-top: 20px;
            text-align: center;
            font-size: 0.9em;
            max-width: 600px;
        }
    </style>
</head>
<body>
    <h1>BLOCK STACKER</h1>
    <canvas id="gameCanvas" width="300" height="600"></canvas>
    <div id="controls">
        <button id="leftBtn">←</button>
        <button id="rightBtn">→</button>
        <button id="rotateBtn">Rotate</button>
        <button id="downBtn">↓</button>
    </div>
    <div id="instructions">
        <p>Desktop Controls: Arrow keys to move, Up arrow (or spacebar) to rotate</p>
        <p>Mobile: Use on-screen buttons</p>
        <p>Clear lines to score points. Game over when blocks reach the top!</p>
    </div>
    <script>
        // Game constants
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const GAME_SPEED = 500; // Slower speed (milliseconds per drop)
        
        // Game variables
        let board = [];
        let currentPiece;
        let score = 0;
        let dropCounter = 0;
        let lastTime = 0;
        let gameOver = false;
        
        // Initialize the game board
        for (let r = 0; r < ROWS; r++) {
            board[r] = [];
            for (let c = 0; c < COLS; c++) {
                board[r][c] = 0;
            }
        }
        
        // Piece shapes (slightly different from traditional Tetris)
        const PIECES = [
            [[1, 1, 1], [0, 1, 0]],
            [[1, 1], [1, 1]],
            [[1, 1, 0], [0, 1, 1]],
            [[0, 1, 1], [1, 1, 0]],
            [[1, 1, 1, 1]],
            [[1, 1, 1], [1, 0, 0]],
            [[1, 1, 1], [0, 0, 1]]
        ];
        
        // Colors for pieces
        const COLORS = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#FDCB6E", "#6C5CE7", "#FFA07A", "#55E6C1"];
        
        // Get the canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game loop
        function gameLoop(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;
            
            if (!gameOver) {
                dropCounter += deltaTime;
                if (dropCounter > GAME_SPEED) {
                    moveDown();
                    dropCounter = 0;
                }
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Draw the game
        function draw() {
            ctx.fillStyle = '#2C3E50';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw the board
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) {
                        ctx.fillStyle = COLORS[board[r][c] - 1];
                        ctx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                    }
                }
            }
            
            // Draw the current piece
            if (currentPiece) {
                ctx.fillStyle = COLORS[currentPiece.colorIndex];
                for (let r = 0; r < currentPiece.shape.length; r++) {
                    for (let c = 0; c < currentPiece.shape[r].length; c++) {
                        if (currentPiece.shape[r][c]) {
                            ctx.fillRect((currentPiece.x + c) * BLOCK_SIZE, (currentPiece.y + r) * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                        }
                    }
                }
            }
            
            // Draw score
            ctx.fillStyle = '#FFF';
            ctx.font = '16px Arial';
            ctx.fillText('Score: ' + score, 10, 25);

            // Draw game over screen
            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#FFF';
                ctx.font = '30px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 50);
                
                ctx.font = '20px "Press Start 2P"';
                ctx.fillText('Score: ' + score, 10, 25);
                
                ctx.font = '12px "Press Start 2P"';
                ctx.fillText('Press SPACE', canvas.width / 2, canvas.height / 2 + 50);
                ctx.fillText('to restart', canvas.width / 2, canvas.height / 2 + 70);
            }
        }
        
        // Get a random piece
        function getRandomPiece() {
            const shapeIndex = Math.floor(Math.random() * PIECES.length);
            return {
                shape: PIECES[shapeIndex],
                x: Math.floor(COLS / 2) - 1,
                y: 0,
                colorIndex: shapeIndex
            };
        }
        
        // Check for collision
        function collision() {
            for (let r = 0; r < currentPiece.shape.length; r++) {
                for (let c = 0; c < currentPiece.shape[r].length; c++) {
                    if (currentPiece.shape[r][c]) {
                        const newX = currentPiece.x + c;
                        const newY = currentPiece.y + r;
                        if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && board[newY][newX])) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // Merge the piece with the board
        function mergePiece() {
            for (let r = 0; r < currentPiece.shape.length; r++) {
                for (let c = 0; c < currentPiece.shape[r].length; c++) {
                    if (currentPiece.shape[r][c]) {
                        board[currentPiece.y + r][currentPiece.x + c] = currentPiece.colorIndex + 1;
                    }
                }
            }
        }
        
        // Clear completed lines
        function clearLines() {
            let linesCleared = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r].every(cell => cell !== 0)) {
                    board.splice(r, 1);
                    board.unshift(new Array(COLS).fill(0));
                    linesCleared++;
                    r++; // Check the same row again
                }
            }
            score += linesCleared * 100;
        }
        
        // Reset the game
        function resetGame() {
            board = [];
            for (let r = 0; r < ROWS; r++) {
                board[r] = new Array(COLS).fill(0);
            }
            score = 0;
            currentPiece = getRandomPiece();
            gameOver = false;
        }
        
        // Handle key presses
        document.addEventListener('keydown', handleInput);
        
        function handleInput(e) {
            if (gameOver) {
                if (e.code === 'Space') {
                    resetGame();
                }
                return;
            }

            if (!currentPiece) return;
            
            if (e.key === 'ArrowLeft') {
                moveLeft();
            } else if (e.key === 'ArrowRight') {
                moveRight();
            } else if (e.key === 'ArrowDown') {
                moveDown();
            } else if (e.key === 'ArrowUp') {
                rotatePiece();
            } else if (e.code === 'Space') {
                rotatePiece();
            }
        }
        
        function moveLeft() {
            currentPiece.x--;
            if (collision()) currentPiece.x++;
        }
        
        function moveRight() {
            currentPiece.x++;
            if (collision()) currentPiece.x--;
        }
        
        function moveDown() {
            currentPiece.y++;
            if (collision()) {
                currentPiece.y--;
                mergePiece();
                clearLines();
                currentPiece = getRandomPiece();
                
                if (collision()) {
                    gameOver = true;
                }
            }
        }
        
        // Rotate the current piece
        function rotatePiece() {
            const rotated = currentPiece.shape[0].map((_, i) => 
                currentPiece.shape.map(row => row[i]).reverse()
            );
            const prevShape = currentPiece.shape;
            currentPiece.shape = rotated;
            if (collision()) {
                currentPiece.shape = prevShape;
            }
        }
        
        // Mobile controls
        document.getElementById('leftBtn').addEventListener('click', moveLeft);
        document.getElementById('rightBtn').addEventListener('click', moveRight);
        document.getElementById('downBtn').addEventListener('click', moveDown);
        document.getElementById('rotateBtn').addEventListener('click', rotatePiece);
        
        // Show mobile controls on touch devices
        if ('ontouchstart' in window || navigator.maxTouchPoints) {
            document.getElementById('controls').style.display = 'block';
        }
        
        // Start the game
        resetGame();
        gameLoop();
    </script>
</body>
</html>